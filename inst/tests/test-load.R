readLines("inst/tests/data/Coartic_Block1_001P00XS1.txt")



# Wrong file encoding
# In readLines(con) : line 44 appears to contain an embedded nul
file_name <- "inst/tests/data/MP_Block1_001P00XA1.txt"
stri_read_lines(file_name)

# Crashed experiment
file_name <- "inst/tests/data/MP_Block1_001P00XA1.txt"
stri_read_lines(file_name)

# No footer
file_name <- "inst/tests/data/Coartic_Block1_001P00XS1.txt"
stri_read_lines(file_name)

test <- dir("L://DataAnalysis/PhonAwareness/TimePoint2/Blending", ".txt", full.names = TRUE)
d <- lapply(test[11], LoadData)
lapply(d, head)








#' Reduce and summarize data from an eprime experiment
#'
#' @param file_name a path to a .txt file generated by Eprime
#' @param stim_to_extract a list of stimuli to be extracted from the text file
#' @param trial_level eprime text files are nested. This argument indicates the
#'   level of the nested where trial-level data is located.
#' @return a data.frame containing the trial by trial responses during the task.
#'   As a side-effect of this function, a .csv file of the returned data.frame
#'   is written in the same directory as the file_name fed into this function.
ProcessFile <- function(file_name, trial_level) {
  require(tools)
  require(plyr)
  require(stringr)
  eprime_log <- load_eprime(file_name)
  file_basename <- file_path_sans_ext(file_name)
  logname <- basename(file_basename)

  # Extract items
  stim <- c(Level = "Level", stim_to_extract)
  parsed_eprime_log <- Map(GetValuesOfStimdataType(eprime_log), stim)

  # Exclude items that are not nested at the trial level
  non_trials <- which(parsed_eprime_log$Level != trial_level)
  parsed_eprime_log$Level <- parsed_eprime_log$Level[-non_trials]
  parsed_eprime_log$Running <- parsed_eprime_log$Running[-non_trials]

  same_length <- length(unique(lapply(parsed_eprime_log, length))) == 1

  if (!same_length) {
    msg <- "There is not an equal number of stimuli attributes across trials"
    msg2 <- character(0)
    msg2 <- str_c(names(parsed_eprime_log), sapply(parsed_eprime_log, length), sep = ": ")
    error <- str_c(c(msg, msg2), collapse = "\n")
    stop(error)
  }

  # Add trial numbers, eprime filename, session date
  stimdata <- data.frame(parsed_eprime_log, stringsAsFactors = FALSE)

  # If the data-frame is empty, use rbind.fill to make a row of NA values
  if (nrow(stimdata) == 0) {
    stimdata <- rbind.fill(stimdata, data.frame(DataName = logname))
  } else {
    stimdata$DataName <- logname
  }

  dates <- str_extract(eprime_log, perl("(?<=SessionDate: ).*"))
  date <- unique(Filter(Negate(is.na), dates))
  stimdata$Date <- date

  # Number Familiarization and Testing trials separately
  stimdata <- ddply(stimdata, "Running", transform,
                    TrialNumber = seq_along(Running))

  # Saved derived data.
  output_name <- paste0(file_basename, "_out.csv")
  write.csv(stimdata, file = output_name, row.names = FALSE)
  return(stimdata)
}

eprime_log <- load_eprime(file_name)
eprime_log <- read_eprime(file_name)


extract_header <- function(eprime_log) {




}

#' Make a function that extracts lines between a start-line tag and an end-line
#' tag
#'
#' The header is delimited by `*** Header Start ***` and `*** Header End ***`
#' lines. The footer is similarly delimited by `*** LogFrame Start ***` and `***
#' LogFrame End ***` lines. Therefore, we define a general function for grabbing
#' text between delimiter lines, and enclose the start/end patterns to create
#' specific functions that grab a header or footer.
#'
#' The chunks are assumed to be unique areas in the stimulus log, and the script
#' returns a warning if multiple instances of a starting pattern or endning
#' pattern are found.
#'
#' @param start_pattern the delimiter for the line at the start of the chunk
#' @param end_pattern the delimiter for the line at the end of the chunk
#' @param eprime_log A character vector of the text lines of the stimulus log
#'   output by E-Prime. `eprime_log` is a parameter in the function returned
#'   by `make_chunk_extractor`.
#' @return a function that extracts the lines between `start_pattern` and
#'   `end_pattern`
#' @examples
#' Header <- make_chunk_extractor(start_pattern = '^\\*{3} Header Start \\*{3}$',
#'                              end_pattern = '^\\*{3} Header End \\*{3}$')
make_chunk_extractor <- function(start_pattern, end_pattern) {
  function(eprime_log) {
    # Find the indices of the start-pattern and end-pattern tags.
    start_index <- grep(pattern = start_pattern, x = eprime_log)
    end_index <- grep(pattern = end_pattern, x = eprime_log)

    if (length_zero(start_index)) {
      warning(paste0(start_pattern, " not found in eprime log"))
    }

    if (length_zero(end_index)) {
      warning(paste0(end_pattern, " not found in eprime log"))
    }

    if (length_zero(start_index) || length_zero(end_index)) {
      start_index <- 0
      end_index <- 0
    }


#     # Warn if more than one chunk delimeter is found.
#     make_warning <- function(pattern) {
#       path <- attr(eprime_log, "path")
#       warning(paste0("Multiple ", pattern, " patterns found in ", path))
#     }
#
#     if (!length_one(start_index)) {
#       make_warning(start_pattern)
#       start_index <- start_index[1]
#     }
#
#     if (!length_one(end_index)) {
#       make_warning(end_pattern)
#       end_index <- end_index[1]
#     }
#
    # Slice the lines of text that constitute the desired chunk.
    chunk <- eprime_log[start_index:end_index]
    chunk
  }
}


#' Extract the header or footer from a stimulus log
#'
#' @param eprime_log A character vector of the text lines of the stimulus log
#'   output by E-Prime. Typically, created by a call to `ReadStimulusLog()`.
#' @return A character vector, the lines of text that costitute the header or
#'   footer of `eprime_log`.
#' @rdname Header
extract_header <- make_chunk_extractor(patterns$header_start, patterns$header_end)
extract_footer <- make_chunk_extractor(patterns$footer_start, patterns$footer_end)

header <- extract_header(eprime_log)
extract_footer(eprime_log)




eprime_log <- read_eprime(file_name)



# Convert a vector of colon-separated values into a list of named elements.
#
#   > example <- c("Item: 1", "OtherItem: Stuff", "Last Item: Whatever")
#   > Listify(example)
#   $Item
#   [1] "1"
#
#   $OtherItem
#   [1] "Stuff"
#
#   $`Last Item`
#   [1] "Whatever"
#
listify <- function(colon_sep_values) {
  # Infer level of nesting by counting tabs
  tab_count <- str_count(colon_sep_values[1], "\\t")
  level <- tab_count + 1
  colon_sep_values <- c(colon_sep_values, paste0("Eprime.Level: ", level))

  # Clean up the lines and listify
  colon_sep_values <- str_trim(colon_sep_values)
  colon_sep_values <- Filter(Negate(is_bracket), colon_sep_values)

  splits <- str_split_fixed(colon_sep_values, pattern = ": ", 2)
  structure(as.list(splits[, 2]), names = splits[, 1])
}

eprime_list <- parsed[[2]]
clean_up_list <- function(eprime_list) {
  level_name <- eprime_list[["Running"]]
  if (!is.null(level_name)) {
    # Remove the level name from the names in the list
    eprime_list <- set_which_name(eprime_list, level_name, "Eprime.LevelIndex")
    eprime_list[["Eprime.LevelIndex"]] <- paste0(level_name, "_", eprime_list[["Eprime.LevelIndex"]])
    names(eprime_list) <- str_replace(names(eprime_list), paste0(level_name, "\\."), "")
  }
  eprime_list
}


which_name <- function(list, name) {
  which(names(list) == name)
}

set_which_name <- function(list, name, new_name) {
  index <- which_name(list, name)
  names(list)[index] <- new_name
  list
}



loaded <- read_eprime(file_name)
chunked <- extract_frames(loaded)
parsed <- lapply(chunked, listify)
parsed2 <- lapply(parsed, clean_up_list)

super_parse <- functional::Compose(listify, clean_up_list)
super_parsed <- lapply(chunked, super_parse)



has_level_one <- function(xs) pluck("Eprime.Level")(xs) == "1"
parsed2 <- Filter(Negate(has_level_one), parsed2)

eprime_lists <- super_parsed





partition_by_levels <- function(eprime_lists) {

  level_numbers <- as.numeric(sapply(eprime_lists, pluck("Eprime.Level")))
  levels <- unique(level_numbers)

  has_this_level <- function(level) {
    function(xs) xs[["Eprime.Level"]] == as.character(level)
  }

  partitioned <- list()

  for (level in levels) {
    level_name <- paste0("Level", level)
    partitioned[[level_name]] <- Filter(has_this_level(level), eprime_lists)
  }

  lapply(partitioned, as.data.frame)


  these_levels



}

parsed3 <- lapply(parsed2, as.data.frame)

levels <- sapply(parsed2, pluck("Eprime.Level"))
level_ones <- str_detect_which(levels, "1")



pluck <- function(name) {
  function(xs) xs[[name]]
}



clean_up_header <- function(eprime_log) {
  header <- extract_header(loaded)

  # Landmark lines for extraction
  exp_line <- str_detect_which(header, "Experiment:")
  clock_line <- str_detect_which(header, "Clock.Information:")
  after_last_level <- max(str_detect_which(header, "LevelName: ")) + 1

  # Default lines to use, in case landmarks are not available
  first_line <- if (length_zero(exp_line)) after_last_level else exp_line
  last_line <- if (length_zero(clock_line)) length(header) else clock_line
  before_last_line <- last_line - 1

  # Include basename in header
  clean_header <- header[seq(first_line, before_last_line)]
  basename_pseudo_line <- paste0("Basename: ", attr(eprime_log, "basename"))
  c(basename_pseudo_line, clean_header)
}






MakeDetector <- function(string) {
  function(set) TRUE %in% str_detect(set, string)
}

MakeExtractor <- function(name) {
  function(set) getElement(set, name)
}

# x <- 1
# first(NA)
# first(NULL)
# first(character(0))
first <- function(x) `if`(length(x) > 0, x[1], NULL)

# ExtractHeader <- function(eprime_log) {
#   header_start <- "\\*\\*\\* Header Start \\*\\*\\*"
#   header_end <- "\\*\\*\\* Header End \\*\\*\\*"
#   # TODO
# }










# Define the items to extract
stim_to_extract <- list(Filename = "Filename", Running = "Running",
                        TargetWord = "TargetWord",
                        PhonotacticProb = "PhonotacticProb",
                        Duration = "Duration", XResponse = "XResponse")

# Which level of the log has each trial's data?
trial_level <- 3

# Load everyone's data
ensemble <- ldply(data_files, ProcessFile, stim_to_extract, trial_level)
str(ensemble)



eprime_log <- load_eprime(file_name)

# Also vectorised over pattern
str_detect("aecfg", letters)

GetValuesOfStimdataType <- function(eprime_log) {
  # Enclose the value for "eprime_log" inside another function that looks for all
  # stimdata of a given type.
  function(stimdataType) {
    # The stimdata for each trial is logged using the following pattern:
    # "\t\t{stimdataType}: {value}".  Create a regular expression that can
    # be used to find the line in each trial where the stimdataType is logged.
    stimdata_pattern <- sprintf('(\t)+%s: ', stimdataType)
    # Extract the lines of the eprime_log where stimdataType is logged.
    eprime_log_lines <- grep(stimdata_pattern, eprime_log, value = TRUE)
    stimdata_values <- sub(stimdata_pattern, '', eprime_log_lines)
    return(stimdata_values)
  }
}







